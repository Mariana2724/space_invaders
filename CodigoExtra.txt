CÓDIGO INICIAL DA MAIN:

		/*initGame();
	-----Enemies enemyGroup;
	-----enemyGroup.addEnemy(new Enemy_4(0, 2, 1));
	//thread enemyThread(moveEnemyAutomatically, ref(enemyGroup));

	
	---------NavePlayer nave(57, 25);
	Bullets bullet(57, 25.3,2);


	int ch = 0; // To store user input
	//this_thread::sleep_for(delay);
	while (ch != 'q') {
		clear(); // Clear the screen
		//enemyGroup.moveAllEnemies();
		//this_thread::sleep_for(chrono::milliseconds(100));
		enemyGroup.drawAllEnemies();	
		enemyGroup.moveAllEnemies();
		bullet.moveBullet(ch);
		bullet.draw();
		nave.draw();
		
		refresh(); // Refresh the screen
		ch = getch(); // Get user input
		// Check user input and update object position
		nave.movementPlayer(ch);
	}
	//enemyThread.join();
	endwin(); // End the curses library*/

	-----------------------//-------------------------//----------------------------------//---------------------------
	player-> update position
o player tem shot - shot tem list<shot> e moveShot
PLAYERUI tem draw
Game-> tem list<Inimigos>
	tem funções startGame e runGame

	void run(void){
		while(run_game){ //flag
		ch=getkey();
		Player::update_position(ch);
		Inimigo::update_position();
		sleep(50ms);//velocidade do jogo-> influencia na velocidade em q mexo no jogo
		}
	}
	TEMPOS DIFERENTES PARA DIFERENTES OBJETOS:
		contador para verificar a multiplicidade com 50 ms
		verificar o tempo que já passou desde a ultima vez 
		start_time=get_time();
		current_time=get_time();

		if(current_time-start_time >=update_time){
			Inimigo::update_position();
		}

		O QUE ESTAVA NA MAIN

	int height = 3;
	int width = 5;
	int x = (COLS - width) / 2; // Center the object horizontally
	int y = (LINES - height) / 2; // Center the object vertically
	-----------------------//-------------------------//----------------------------------//---------------------------

	
					string ChooseSpaceShip[3] = { "(1)", "(2)", "(3)" };
					int SpaceHighlight = 0;
					int a = 1;
						for (int i = 0; i < 3; i++) {
							if (i == SpaceHighlight) {
								wattron(space, A_REVERSE);
							}
							mvwprintw(space, 5, a, ChooseSpaceShip[i].c_str());
							a += 10;
							wattroff(space, A_REVERSE);
						}

					int ch = wgetch(space);
					switch (ch) {
					case KEY_LEFT:
						SpaceHighlight--;
						if (SpaceHighlight == -1) {
							SpaceHighlight = 0;
						}
						break;
					case KEY_RIGHT:
						SpaceHighlight++;
						if (SpaceHighlight == 3) {
							SpaceHighlight = 2;
						}
						break;
					case '\n': // Enter key
						break;
					case 'q':
						wborder(space, ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ');
						newW = false;
						werase(space);
						wrefresh(space);
						break;
					default:
						break;
					}
					wrefresh(space);
					/*
					wrefresh(space);
					if (ch == 'q') {
						wborder(space, ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '); // Erase frame around the window
						newW = false;
						werase(space);
						wrefresh(space);
					}*/
					endwin();
				}
				wborder(space, ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ');
				newW = false;
				werase(space);
				wrefresh(space);
				
				//break;
			}
			else {
				break;
			}

		}
	}
	endwin();

}
___________________________
colors que há
COLOR_BLACK
COLOR_RED
COLOR_GREEN
COLOR_YELLOW
COLOR_BLUE
COLOR_MAGENTA
COLOR_CYAN
COLOR_WHITE
if (key == 'p') {
			/*WINDOW* space = newwin(yMax / 4, xMax / 4, yMax / 2 + 6, xMax / 2 + 20);
			box(space, 0, 0);
			if(key==)*/
		}
---------------------------------//-----------------------------//-----------------------
MOVIMENTO DOS INIMIGOS ANTERIOR
/* if (direction == 0) { // Movimento para a direita
                x++;
                if (x >= COLS - 10) { // Verifica se chegou ao limite direito
                    x = COLS - 10;
                    direction = 1; // Muda a direção para baixo
                }
            }
            else if (direction == 1) { // Movimento para baixo
                moveDown();
                a++;
                if (a == 2) {
                    direction = 2;
                    a = 0;
                }
                if (y >= LINES - 12) { // Verifica se chegou ao limite inferior
                    y = LINES - 12; // Ajusta para o limite inferior
                    direction = 2; // Muda a direção para a esquerda
                }
            }
            else if (direction == 2) { // Movimento para a esquerda
                moveLeft();
                if (x <= 0) { // Verifica se chegou ao limite esquerdo
                    x = 0;
                    moveDown();
                    a++;
                    if (a == 1) {
                        direction = 0; // Muda a direção para a direita
                        a = 0;
                }
                    
                }
            }
            break;*/
            if (direction == 0) { // Movimento para a direita
                x++;
                if (x >= COLS - 10) { // Verifica se chegou ao limite direito
                    x = COLS - 10;
                    direction = 1; // Muda a direção para baixo
                }
            }
            else if (direction == 1) { // Movimento para baixo
                moveDown();
                direction = 2;
                if (y >= LINES - 12) { // Verifica se chegou ao limite inferior
                    y = LINES - 12; // Ajusta para o limite inferior
                    direction = 2; // Muda a direção para a esquerda
                }
            }
            else if (direction == 2) { // Movimento para a esquerda
                moveLeft();
                if (x <= 0) { // Verifica se chegou ao limite esquerdo
                    x = 0;
                    moveDown();
                    direction = 0; // Muda a direção para a direita
                }
            }
            break;
________________________________________
MOVIMNETO DOS INIMIGOS TIAGO
      if (direction == 0) { // Movimento para a direita
                x++;
                if (x >= COLS - 10) { // Verifica se chegou ao limite direito
                    x = COLS - 10;
                    direction = 1;
                    flagmudança = 1;// Muda a direção para baixo
                }
            }
            else if (direction == 1) { // Movimento para baixo
                moveDown();
                if (x == 0){
                    direction = 0;
                }
                else if(x==COLS-10) {
                    direction = 2;
                }
                flagmudança = 1;
                if (y >= LINES - 12) { // Verifica se chegou ao limite inferior
                    y = LINES - 12; // Ajusta para o limite inferior
                }
            }
            else if (direction == 2) { // Movimento para a esquerda
                moveLeft();
                if (x <= 0) { // Verifica se chegou ao limite esquerdo
                    x = 0;
                    direction = 1; // Muda a direção para a direita
                    flagmudança = 1;
                }
            }
            break;
        case 4:
            moveRight();
            if (x >= COLS - 10) { // Chegou ao lado direito
                x = 0; // Ajusta a posição para não sair do limite
            }